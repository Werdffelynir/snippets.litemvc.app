[code]// -------------------------------------------------------------------------------------------------
// |  Написал для поверка имени файла. Строка должна иметь символы "tpl.XXX.php" (.php|.html|.xml)
if(preg_match_all("/^([tpl\.])+([a-z0-9])+\.(php|html|xml)/i",$suectname)){
    # Code
}



// -------------------------------------------------------------------------------------------------
// |  Получить расширение файла

// |  Елементарный:
preg_replace("/.*?\./", '', 'photo.jpg');  


// |  Изображения (jpg, png, ...)
/\.(?:jp(?:e?g|e|2)|gif|png|tiff?|bmp|ico)$/i  


// |  Программы (exe, xpi, ...)
/\.(?:exe|msi|dmg|bin|xpi|iso)$/i  


// |  Архивы (zip, rar, ...)
/\.(?:z(?:ip|[0-9]{2})|r(?:ar|[0-9]{2})|jar|bz2|gz|tar|rpm)$/i  


// |  Аудио (mp3, wav, ...)
/\.(?:mp3|wav|og(?:g|a)|flac|midi?|rm|aac|wma|mka|ape)$/i  


// |  Видео (mpeg, avi, ...)
/\.(?:mpeg|ra?m|avi|mp(?:g|e|4)|mov|divx|asf|qt|wmv|m\dv|rv|vob|asx|ogm)$/i  


// -------------------------------------------------------------------------------------------------
// |  Проверка имени файла

Изображения (jpg, png, ...)
if (preg_match("/(^[a-zA-Z0-9]+([a-zA-Z\_0-9\.-]*))$/" , $filename)==NULL) {  
        echo "invalid filename";  
        exit;  
}  


// |  Удалить все аттрибуты у всех тегов, кроме a, p, img
preg_replace("/<([^ap(img)].*?)\s.*?>/is", "<\\1>", $string);  


// |  Выбрать все параметры тегов:
$string = '<table border=\'0\'       cellpadding  = "0" cellspacing=0 style= "border-collapse: collapse">';  
if (preg_match_all('#\s+([^=\s]+)\s*=\s*((?(?="|\') (?:"|\')([^"\']+)(?:"|\') | ([^\s]+)))#isx', $string, $matches)) {  
  print_r($matches);  
}  


// |  Конвертор HTML в текст
// $document на выходе должен содержать HTML-документ.  
// Необходимо удалить все HTML-теги, секции javascript,  
// пробельные символы. Также необходимо заменить некоторые  
// HTML-сущности на их эквивалент.  
$search = array ("'<script[^>]*?>.*?</script>'si",  // Вырезает javaScript  
                 "'<[\/\!]*?[^<>]*?>'si",           // Вырезает HTML-теги  
                 "'([\r\n])[\s]+'",                 // Вырезает пробельные символы  
                 "'&(quot|#34);'i",                 // Заменяет HTML-сущности  
                 "'&(amp|#38);'i",  
                 "'&(lt|#60);'i",  
                 "'&(gt|#62);'i",  
                 "'&(nbsp|#160);'i",  
                 "'&(iexcl|#161);'i",  
                 "'&(cent|#162);'i",  
                 "'&(pound|#163);'i",  
                 "'&(copy|#169);'i",  
                 "'&#(\d+);'e");                    // интерпретировать как php-код  
$replace = array ("",  
                  "",  
                  "\\1",  
                  "\"",  
                  "&",  
                  "<",  
                  ">",  
                  " ",  
                  chr(161),  
                  chr(162),  
                  chr(163),  
                  chr(169),  
                  "chr(\\1)");  
  
$text = preg_replace($search, $replace, $document);  


// |  Проверяем, является ли переменная числом

if (!preg_match("|^[\d]+$|", $var)) ...  

    
// |  Проверка на число через регулярное выражение

if(preg_match('/^\d+$/', $var)) echo $var;  

    
// |  Проверить, что в строке есть число (одна или более цифра)

preg_match('/(\d+)/s', "article_123.html", $pockets);  
// Совпадение (подвыражение в скобках) окажется в $pockets[1].  
echo $pockets[1]; // выводит 123  

    
// |  Простейший разбор даты

$str = " 15-16/2000       "; // к примеру  
$re = '{  
  ^\s*(                  # начало строки  
    (\d+)                  # день  
      \s* [[:punct:]] \s*  # разделитель  
    (\d+)                  # месяц  
      \s* [[:punct:]] \s*  # разделитель  
    (\d+)                  # год  
  )\s*$                  # конец строки  
}xs';  
// Разбиваем строку на куски при помощи preg_match().  
preg_match($re, $str, $pockets) or die("Not a date: $str");  
// Теперь разбираемся с карманами.  
echo "Дата без пробелов: '$pockets[1]' <br>";  
echo "День: $pockets[2] <br>";  
echo "Месяц: $pockets[3] <br>";  
echo "Год: $pockets[4] <br>";  

    
// |  Проверка формата времени. date: mm:hh.

$time = "10:11";  
if (!preg_match('/^([0-1][0-9]|[2][0-3]):([0-5][0-9])$/', $time)) echo "Время введено неправильно";  

    
// |  Замена по шаблону

$text = htmlspecialchars(file_get_contents(__FILE__));  
$html = preg_replace('/(\$[a-z]\w*)/is', '<b>$1</b>', $text);  
echo "<pre>$html</pre>";  

    
// |  "Жадные" квантификаторы. Использование квантификаторов увеличивает скорость поиска, особенно в тех случаях, когда строка не соответствует регулярному выражению.

$str = "Hello, this <b>word</b> is <b>bold</b>!";  
$re = '|<(\w+) [^>]* > (.*) </\1>|xs';  
preg_match($re, $str, $pockets) or die("Нет тэгов.");  
echo htmlspecialchars("'$pockets[2]' обрамлено тэгом '$pockets[1]'");  

    
// |  Сравнение "жадных" и "ленивых" квантификаторов

$str = '[b]жирный текст [b]а тут - еще жирнее[/b] вернулись[/b]';  
$to  = '<b>$1</b>';  
$re1 = '|\[b\] (.*)  \[/b\]|ixs';  
$re2 = '|\[b\] (.*?) \[/b\]|ixs';  
$result = preg_replace($re1, $to, $str);  
echo "Жадная версия: ".htmlspecialchars($result)."<br />";  
$result = preg_replace($re2, $to, $str);  
echo "Ленивая версия: ".htmlspecialchars($result)."<br />";  

    
// |  Применение пользовательских функций в preg_replace_callback()
// |  Пользовательская функция. Будет вызываться для каждого совпадения с регулярным выражением.

function toUpper($pockets) {  
  return $pockets[1].strtoupper($pockets[2]).$pockets[3];  
}  
$str = '<hTmL><bOdY bgcolor="white">Three captains, one ship.</bOdY></html>';  
$str = preg_replace_callback('{(</?)(\w+)(.*?>)}s', "toUpper", $str);  
echo htmlspecialchars($str);  


    
####################################################################################################
#############   Проверка URL на корректность
//Поддерживает все, что только может быть в УРЛ... Помните о том, что вы должны не только проверять, но и принимать новое значение от функции, т.к. та дописывает "http://" в случае его отсутствия.


// функция для удаления опасных сиволов  
function pregtrim($str) {  
   return preg_replace("/[^\x20-\xFF]/","",@strval($str));  
}  
  
//  
// проверяет URL и возвращает:  
//  *  +1, если URL пуст  
//        if (checkurl($url)==1) echo "пусто"  
//  *  -1, если URL не пуст, но с ошибками  
//        if (checkurl($url)==-1) echo "ошибка"  
//  *  строку (новый URL), если URL найден и отпарсен  
//        if (checkurl($url)==0) echo "все ок"  
//        либо if (strlen(checkurl($url))>1) echo "все ок"  
//  
//  Если протокола не было в URL, он будет добавлен ("http://")  
//  
function checkurl($url) {  
   // режем левые символы и крайние пробелы  
   $url=trim(pregtrim($url));  
   // если пусто - выход  
   if (strlen($url)==0) return 1;  
   //проверяем УРЛ на правильность  
   if (!preg_match("~^(?:(?:https?|ftp|telnet)://(?:[a-z0-9_-]{1,32}".  
   "(?::[a-z0-9_-]{1,32})?@)?)?(?:(?:[a-z0-9-]{1,128}\.)+(?:com|net|".  
   "org|mil|edu|arpa|gov|biz|info|aero|inc|name|[a-z]{2})|(?!0)(?:(?".  
   "!0[^.]|255)[0-9]{1,3}\.){3}(?!0|255)[0-9]{1,3})(?:/[a-z0-9.,_@%&".  
   "?+=\~/-]*)?(?:#[^ '\"&<>]*)?$~i",$url,$ok))  
   return -1; // если не правильно - выход  
   // если нет протокала - добавить  
   if (!strstr($url,"://")) $url="http://".$url;  
   // заменить протокол на нижний регистр: hTtP -> http  
   $url=preg_replace("~^[a-z]+~ie","strtolower('\\0')",$url);  
   return $url;  
}  


В результате для проверки нужно использовать нечто такое:


    $url=checkurl($url); // перезаписали УРЛ в самого себя  
    if ($url) exit("Ошибочный URL");  

Еще пример. Выбрать локальные URL, ссылки

Как можно выбрать не просто все урлы в HTML странице а те которые не начинаются на http://, другими словами локальные.


    preg_match_all("#\s(?:href|src|url)=(?:[\"\'])?(.*?)(?:[\"\'])?(?:[\s\>])#i", $buffer, $matches);  

Найти и заменить все "http://" на ссылки

Вариант 1:


    $text = preg_replace('#(?<!\])\bhttp://[^\s\[<]+#i',  
        "<a href=\"$0\" target=_blank><u>Посмотреть на сайте</u></a>",  
        nl2br(stripslashes($text)));  

Вариант 2, с выделением домена:


    // Cuts off long URLs at $url_length, and appends "..."  
    function reduceurl($url, $url_length) {  
        $reduced_url = substr($url, 0, $url_length);  
        if (strlen($url) > $url_length) $reduced_url .= '...';  
        return $reduced_url;  
    }  
      
    $linktext = preg_replace("#\[(([a-zA-Z]+://)([a-zA-Z0-9?&%.;:/=+_-]*))\]#e", "'<a href=\"$1\" target=\"_blank\">' . reduceurl(\"$3\", 30) . '</a>'", $linktext);  

Вариант 3, учитывающий "WWW."


    // match protocol://address/path/file.extension?some=variable&another=asf%  
    $text = preg_replace("/\s(([a-zA-Z]+:\/\/)([a-z][a-z0-9_\..-]*[a-z]{2,6})([a-zA-Z0-9\/*-?&%]*))\s/i", " <a href=\"$1\">$3</a> ", $text);  
      
    // match www.something.domain/path/file.extension?some=variable&another=asf%  
    $text = preg_replace("/\s(www\.([a-z][a-z0-9_\..-]*[a-z]{2,6})([a-zA-Z0-9\/*-?&%]*))\s/i", " <a href=\"http://$1\">$2</a> ", $text);  

Обратные ссылки


    $str = "Hello, this <b>word</b> is bold!";  
    $re = '|<(\w+) [^>]* > (.*?) </\1>|xs';  
    preg_match($re, $str, $pockets) or die("Нет тэгов.");  
    echo htmlspecialchars("'$pockets[2]' обрамлено тэгом '$pockets[1]'");  

Получение строки GET-запроса.

Для начала поставим самую простую задачу - получить часть URL, содержащую GET-параметры.


    function ggp($url) { // get GET-parameters string  
        preg_match('/^(.+?)(\?.*?)?(#.*)?$/', $url, $matches);  
        $gp = (isset($matches[2])) ? $matches[2] : '';  
        return $gp;  
    }  

Не стоит забывать, что адрес может вовсе не содержать никакого GET-запроса, и массив вхождений может не иметь второго элемента
Исключение GET-запроса из URL

Иногда нужно получить URL без GET-параметров (например, при перенаправлении запросов с помощью mod_rewrite зачастую требуется проводить анализ URL, чтобы сформировать ответ клиенту; нередко для анализа нужна только статическая часть URL, а часть, где передается GET-запрос, не нужна и даже мешает).


    // удаление GET-параметров из URL  
    $str = preg_replace('/^(.+?)(\?.*?)?(#.*)?$/', '$1$3', $url);  

Есть ли в строке параметров сессия (PHPSESSID):



    print $_SERVER['REQUEST_URI'].'<br>';  
    if (preg_match("/=([a-f0-9]{32})&/i", $_SERVER['REQUEST_URI'].'&')){  
     print 'Да';  
     // удалить сессию из строки параметров  
     //print str_replace('&&','&',str_replace('?&','?',preg_replace("/&*sid=([a-f0-9]{32})&*/i", '&', $_SERVER['REQUEST_URI'])));  
     }  
    else print 'Нет';  

Удалить из строки параметр page и добавить другой page.

Этот пример позволяет заменить один параметр на другой не испортив все остальные параметры строки. Если Вы найдете более оптимальное решение, присылайте.


    $href1=str_replace('&&','&',str_replace('?&','?',preg_replace("/&*page=([0-9]{1,3})&*/i", '&', $_SERVER['REQUEST_URI'])));  
    $href1=str_replace('?&','?',$href1.(strpos($href1, '?')===false?'?':'&').'page=');  

Как получить значение переменной из url используя регулярное выражение PHP ?


    $url = 'http://codorama.com/page/index.htm?cat=2&id=2';  
    // получим значение переменной $cat  
    preg_match("/  
        \?  
        (?:.*&)*  
        cat=  
        ([^&]+)  
        /i", $url, $found);  
    echo $found[1];  
      
    // получим значение переменной $id  
    preg_match("/  
        \?  
        (?:.*&)*  
        id=  
        ([^&]+)  
        /i", $url, $found);  
    echo $found[1];  

Проверяем, является ли строка правильным доменным именем

Проверка доменного имени:


    $url = "http://codorama.com/";  
    if (preg_match('/^(http|https|ftp)://([A-Z0-9][A-Z0-9_-]*(?:.[A-Z0-9][A-Z0-9_-]*)+):?(d+)?/?/i', $url)) {  
        echo "Your url is ok.";  
    } else {  
        echo "Wrong url.";  
    }  

Получение всех ссылок со страницы на php

Через регулярные выражения. Вариант 1:


    preg_match_all("/(http:\\/\\/)?([a-z_0-9-.]+\\.[a-z]{2,3}(([ \"'>\r\n\t])|(\\/([^ \"'>\r\n\t]*)?)))/",$buf,$url);  

Через регулярные выражения. Вариант 2:


    $open = file_get_contents('http://codorama.com/links.php');  
    preg_match_all("/<a href=\"(.*)\">(.*)<\/a>/uis", $open, $links);  
    print_r ($links);  

Через регулярные выражения. Вариант 3:


    $str = '<a href="http://www.youtube.com/watch?v=blbEYzlGhAI&list=LLyPrc5qEdqzHB_u8IW1fF7A&feature=mh_lolz">dffdfdf</a>';  
    $find = preg_match_all("/<a\s+href\s*=\s*[\"']*(http:\/\/.*)\s*[^>]*>(.[^<]*)<[\/a]+>/i", $str, $url);  
    print_r($url);    

Через регулярные выражения. Вариант 4:


    $open_url = "http://codorama.com/";  
    $html = file_get_contents($open_url);  
    preg_match_all('~<a.*?href="([^"]+)".*?>(.*?)</a>~s', $html, $matches);  
     print_r($matches);   


####################################################################################################
#############   Парсер ссылок, текста, сайта. Регулярные выражения для php

Парсинг цен на странице сайта/сохраненного файла

Задачи по парсингу интересующих программиста данных из HTML возникают часто и густо. Но беда в том, что HTML-код не всегда хорошего качества. Да еще и вставки на javascript'е. Например:


    <TD>20.02<BR>05:30 <TD class=l>Товар 1<BR>Товар  
    2 <TD><B>35</B> <TD><A href="http://ссылка/"  
    id=sfsd32dfs onclick="return m(this)">26.92</A><BR><A  
    href="http://ссылка/" id=r3_3143svsfd onclick="return  
    m(this)">27.05</A> <TD><B>270.5</B>  
    </TR>  

Те цифры, которые написаны через точку, являются ценами. Задача состоит в том, чтобы собрать все цены, которые находятся между тегами <a>... </a> Видим, что помимо цен между заданными тегами, есть такие, которые идут сразу после тега <TD>, а также стоят между тегами <B>...</B>. Ясно, что описать достаточно точно содержимое атрибутов тега <A> представляется задачей не самой легкой, поэтому надо ее упростить! Любой тег имеет закрывающий знак '>', наша задача описать, что этот знак идет перед ценой, но так как перед ценой может стоять тег <B> и тег <TD>, но эти цены нам не нужны. Каким образом мы узнаем, что цена стоит между тегами <A>...</A>? По тегу, который идет после цены, если это не тег </B>, то это будет либо тег </A> либо <BR>, а так же по тегу перед ценой если этот тег <TD>. Путем таких размышлений мы пришли к выводу, что должно стоять справа, а что должно стоять слева искомой строки, которая описывается как цифры, разделенные точкой: \d*\.\d* То, что должно совпасть слева, мы описали как символ '>', записываем: (?<=>) - выглядит немного странно, но совпадение справа записывается вот так (?<=), а внтури него после ?<= идет символ '>' То, что должно совпасть справа описывается (?=) внутри мы пишем </A>. Теперь опишем, что не должно стоять перед ценой: (?<!<TD>) перед ценой не должен стоять тег <TD>, это и есть негативная ретроспективная проверка. При помощи негативной опережающей проверки опишем, что не должно стоять справа цены: (?!<\/B>) справа от цены не должен стоять тег </B>. Результирующее регулярное выражение, которое описывает все приведенные условия выглядит вот так:


    preg_match_all("/(?<!<TD>)(?<=>)\d*\.\d*(?!<\/B>)(?=<\/A>)/", $string, $matches);  
    print_r($matches);  

После рассмотрения первого примера стоит сделать замечания и пояснения по поводу использования позиционных проверок.

1. Написанные друг за другом проверки применяются независимо друг от друга в одной точке, не меняя ее. Естественно, что совпадение будет найдено, если все проверки совпадут. В нашем примере это были точки перед и после цены. С точки зрения логики применения проверок нет никакой разницы, будет ли стоять проверка на тег <TD> перед проверкой на знак '>'. Правда, с точки зрения оптимизации первой позиционной проверкой должна идти та, которая имеет наибольшую вероятность несовпадения.

2. Совпавшие значения ретроспективных проверок не сохраняются. Т.е. если в нашем примере совпадает опережающая проверка, которая указывает, что после цены идет тег </A>, то сам тег </A>, который заключен в конструкцию (?=) не будет запоминаться в специальных перменных /1,/2 и т.д. Сделано это из-за того, что позиционная проверка совпадает не со строкой, а с местом в строке (она описывает место, где произошло совпадение, а не символы, которые совпали).
3. Нужно указать что PCRE не позволяет делать проверки на совпадение текста произвольной длинны. То есть нельзя делать, например, такую проверку: /(?<=\d+)

Механизм поиска совпадения в ретроспективной проверке реализован так, что при поиске механизму должна подаваться строка фиксированной длины, для того, чтобы в случае несовпадения, механизм мог вернуться назад на фиксированое количество символов и продолжить поиск совпадений в других позиционных проверках. Думаю, что сразу это понять сложно, но представьте себе как происходит поиск совпадения в части (?)(?<=>) вышеописанного регулярного выражения. Берется строка, в которой происходит поиск, отсчитывается от начала столько символов, сколько символов будет в совпадении позиционной проверки, в нашем варианте это 4: <, T, D, > с этого места происходит "заглядывание назад" (ретроспективные проверки на английском языке звучит как lookbhind assertions), т.е. все предыдущие 4 символа проверяются на совпадение со строкой <TD>, если механизм не нашел совпадения, то ему надо вернуться на 4 символа назад, выполнить тоже самое с проверкой (?<=>), т.е. отсчитать один символ, "заглянуть" назад, попробовать найти проверку предыдущего символа с символом '>'. Представьте себе, что условие совпадения состоит из строки нефиксированной длинны: (??) подобная запись должна означать, что перед ценой, не должен стоять тег <TD> в количестве максимимум один экземпляр (либо вообще не стоять). Вот и получается, что после того, как механизм отсчитает 4 символа от начала, он проверит на совпадение с <TD>, но в условии указано, что тега может и не быть вообще, тогда возникает вопрос, на сколько знаков верунться назад, чтобы проверить на совпадение другие проверки. На 4 или вообще не возвращаться? Сразу возникает вопрос, а зачем идти вперед, чтобы потом "заглянуть" назад? Делается это для того, чтобы в случае совпадения всех проверок сразу же начать проверку тех символов, которые идут после позиционных проверок.
Парсер всех внешних и внутренних ссылок со страницы сайта/сохраненного файла

В массиве $vnut только ссылки внутренние, в массиве $vnech только внешние ссылки.


    $html=file_get_contents ('http://www.popsu.net');  
    $url='popsu.net';  
    $vnut=array();  
    $vnech=array();  
    preg_match_all('~<a [^<>]*href=[\'"]([^\'"]+)[\'"][^<>]*>(((?!~si',$html, $matches);  
    foreach ($matches[1] as $val) {  
    if (!preg_match("~^[^=]+://~", $val) || preg_match("~^[^://]+://(www\.)?".$url."~i", $val)) { $vnut[]=$val; }  
    else $vnech[]=$val;  
    }  
    $vnut=array_unique ($vnut);  
    $vnech=array_unique ($vnech);  
    print_r ($vnut);  
    print_r ($vnech);  

Взять то, что находится между тегами <title> и </title>


    if (preg_match('|<title.*?>(.*)</title>|sei', $str, $arr)) $title = $arr[1];  
       else $title='';  

Обратите внимание: берется не нулевой элемент массива, а первый! Если title будет встречаться несколько раз, то будет вырезано от первого и до последнего!

или можно так


    $str = '<title>текст</title>';  
    preg_match('/<title>(.*)<\\/title>/s', $str, $res);  
    print_r($res);  

ещё вариант получения всего, что находится в теге title


    $fp = fopen("http://www.catswhocode.com/blog","r");  
    while (!feof($fp) ){  
        $page .= fgets($fp, 4096);  
    }  
    $titre = eregi("<title>(.*)</title>", $page, $regs);  
    echo $regs[1];  
    fclose($fp);  

Найти текст, заключенный в какой-то тег и заменить его на другой тег

Например: <TITLE> ... </TITLE> заменить аналогично на <МОЙ_ТЕГ> ... </МОЙ_ТЕГ> в HTML-файле:


    preg_replace("!<title>(.*?)</title>!si","<МОЙ_ТЕГ>\\1</МОЙ_ТЕГ>",$string);  

Как вытащить слова из текста?

Это регулярное выражение PHP разбирает текст на отдельные слова, основываясь на определении: слово - это непрерывная последовательность букв английского или русского алфавитов.


    $x="Типа, %^& читайте___люди~~~~__маны__  На... РУССКОМ!! Будете+здоровы.  abc, qwe, zxc";  
    preg_match_all('/([a-zA-Zа-яА-Я]+)/',$x,$ok);  
    for ($i=0; $i<count($ok[1]); $i++) echo $ok[1][$i]."<br>";  

Результат будет таким:


    Типа  
    читайте  
    люди  
    маны  
    На  
    РУССКОМ   
    Будете   
    здоровы   
    abc   
    qwe   
    zxc  

Как заставить работать с русскими буквами в UTF-8?

В PHP это можно решить вот так:


    preg_replace("/[^\p{L}0-9\+\-\_:\.@ ]/u", "", $_string));  

Как получить/найти в тексте шестнадцатеричные значения цветов ?

через регулярные выражения для PHP:


    $string = "#555555";  
    if (preg_match('/^#(?:(?:[a-fd]{3}){1,2})$/i', $string)) {  
    echo "example 6 successful.";  
    }  

Поиск XML/HTML тэгов

Функция, принимает два аргумента. Первый аргумент – это тэг, который вам нужно найти, и второй – это переменная, содержащая XML или HTML.


    function get_tag( $tag, $xml ) {  
      $tag = preg_quote($tag);  
      preg_match_all('{<'.$tag.'[^>]*>(.*?)</'.$tag.'>.'}',  
                       $xml,  
                       $matches,  
                       PREG_PATTERN_ORDER);  
       
      return $matches[1];  
    }  

Получение всех картинок из HTML-документа

Чтобы получить все картинки с веб-страницы задействуем следующие регулярные выражения:


    $images = array();  
    preg_match_all('/(img|src)=("|\')[^"\'>]+/i', $data, $media);  
    unset($data);  
    $data = preg_replace('/(img|src)("|\'|="|=\')(.*)/i', "$3", $media[0]);  
       
    foreach ($data as $url) {  
        $info = pathinfo($url);  
        if (isset($info['extension'])) {  
            if (($info['extension'] == 'jpg') ||  
                    ($info['extension'] == 'jpeg') ||  
                    ($info['extension'] == 'gif') ||  
                    ($info['extension'] == 'png'))  
                array_push($images, $url);  
        }  
    }  


####################################################################################################
#############   Проверка E-mail через регулярные выражения для php
Проверка адреса e-mail

Для поля ввода адреса e-mail добавим в список разрешенных символов знаки "@" и "." и "-", иначе пользователь не сможет корректно ввести адрес. Зато уберем русские буквы и пробел:


    if (preg_match("/[^(\w)|(\@)|(\.)|(\-)]/",$usermail)) {  
            echo "invalid mail";  
            exit;  
    }  

Разбор адесов E-mail.


    $text = "Адреса: user-first@mail.ru, second.user@mail.ru.";  
    $html = preg_replace(  
      '{  
        [\w-.]+             # имя ящика  
        @  
        [\w-]+(\.[\w-]+)*   # имя хоста  
      }xs',  
      '<a href="mailto:$0">$0</a>',  
      $text  
    );  
    echo $html;  

То же самое, но немножко по-другому:


    $html = preg_replace( '/(\S+)@([a-z0-9.-]+)/is', '<a href="mailto:$0">$0</a>', $text);  

Найти в тексте адрес E-mail


    // \S означает "не пробел", а [a-z0-9.]+ -  
    // "любое число букв, цифр или точек". Модификатор 'i' после '/'  
    // заставляет PHP не учитывать регистр букв при поиске совпадений.  
    // Модификатор 's', стоящий рядом с 'i', говорит, что мы работаем  
    // в "однострочном режиме" (см. ниже в этой главе).  
    preg_match('/(\S+)@([a-z0-9.]+)/is', "Привет от somebody@mail.ru!", $p);  
    // Имя хоста будет в $p[2], а имя ящика (до @) - в $p[1].  
    echo "В тексте найдено: ящик - $p[1], хост - $p[2]";  

Превращение E-mail в HTML-ссылку


    $text = "Привет от somebody@mail.ru, а также от other@mail.ru!";  
    $html = preg_replace(  
      '/(\S+)@([a-z0-9.]+)/is',     // найти все E-mail  
      '<a href="mailto:$0">$0</a>', // заменить их по шаблону  
      $text                         // искать в $text  
    );  
    echo $html;  

Проверка логина

Запретим пользователю использовать в своем имени любые символы, кроме букв русского и латинского алфавита, знака "_" (подчерк), пробела и цифр:


    if (preg_match("/[^(\w)|(\x7F-\xFF)|(\s)]/",$username)) {  
            echo "invalid username";  
            exit;  
    }  



####################################################################################################
#############   Проверка строк через регулярные выражения на php


// -------------------------------------------------------------------------------------------------
// |  Является ли строка числом, длиной до 77 цифр:
//Простое решение можетбыть таким:
if (preg_match("/^[0-9]{1,77}$/",$string)) echo "ДА";  

// -------------------------------------------------------------------------------------------------
// |  Проверка повторяющихся символов в строке
//Есть ли в строке идущие подряд символы, не менее 3-х символов подряд (типа "абвгДДДеё", но не "ааббаабб"):
if (preg_match("/(.)\\1\\1/",$string)) echo "yes"; else echo "no";  


// -------------------------------------------------------------------------------------------------
// |  Состоит ли строка только из букв, цифр и "_", длиной от 8 до 20 символов: Цифры, естественно, меняем на нужные
if (preg_match("/^[a-zа-я0-9_]{8,20}$/",$string)){ echo "yes"; }else{ echo "no"; }  


// -------------------------------------------------------------------------------------------------
// |  Проверка строки на допустимость
Есть ли в строке любые символы, кроме допустимых. Допустимыми считаются буквы, цифры и "_". Длину тут проверять нельзя, разве что просто дополнительным условием strlen($string). Не путайте с предыдущим примером - хоть результат и одинаковый, но метод другой, "от противного"
    if ( ! preg_match("/[^a-zа-я0-9_]/",$string))  
       echo "нет посторонних букв (OK)";  
    else  
       echo "есть посторонние буквы (FALSE)";  

       
// -------------------------------------------------------------------------------------------------
// |  Заменить все повторяющиеся пробелы на один
// Не пытайтесь здесь применить str_replace, это хорошая функция, но не для данного примера.
$string=preg_replace("/ХХ+/","Х",$string); // вместо Х поставьте пробел  


// -------------------------------------------------------------------------------------------------
// |  Удаление многократно повторяющихся знаков препинания
//Удаление знаков препинания, которые повторяются больше 3 раз, т.е. !!!!! -> !!!, ????? -> ??? и т.д. Заменяются следующие символы: . ! ? ( )
$text = preg_replace('#(\.|\?|!|\(|\)){3,}#', '\1\1\1', $text);  


// -------------------------------------------------------------------------------------------------
// |  Сложная замена
//В тексте есть некоторые слова, допустим "СЛОВО" и "ЛЯЛЯЛЯ" (и т.д.), которые нужно одинаковым образом заменить на тоже самое, но с добавками. Возможно, слова отсутствуют или встречаются много раз в любом регистре.
//Т.е. если было "слово" или "СлОвО" (или еще как), нужно заменить это на "<b>слово</b>" или "<b>СлОвО</b>" (смотря, как было). Другими словами нужно найти перечень слов в любом регистре и вставить по краям найленных слов фиксированные строки (на "<b>" и "</b>").
$string=preg_replace("/(слово1|слово2|ляляля|слово99)/si","<b>\\1</b>",$string);  


// -------------------------------------------------------------------------------------------------
// |  В простейших случаях для такой задачи можно обойтись без регулярных выражений и задействовать массив значений для функции str_replace()
Добавить <br /> в начало всех строк
$string = preg_replace("/^/", "  
    ", $string);  

    
// -------------------------------------------------------------------------------------------------
// |  Добавить <br /> в конец всех строк
$string = preg_replace("/$/", "  
    ", $string);  

    
// -------------------------------------------------------------------------------------------------
// |  Заменить все символы кроме чисел и запятой на ''
$value = preg_replace('/[^\d,]+/', '', $value); // заменить все символы кроме чисел и запятой на ''  


// -------------------------------------------------------------------------------------------------
// |  Удаление повторяющихся слов (не чувствителен к регистру)
$text = preg_replace("/s(w+s)1/i", "$1", $text);  


// -------------------------------------------------------------------------------------------------
// |  Удаление повторяющейся пунктуации
$text = preg_replace("/.+/i", ".", $text);  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  




// -------------------------------------------------------------------------------------------------
// |  

[/code]